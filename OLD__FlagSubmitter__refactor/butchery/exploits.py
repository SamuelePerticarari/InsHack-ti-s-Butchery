from auth import is_logged
from challenges import get_challenges
from database import get_db
from datetime import datetime
from flask import (
    Blueprint, current_app as app, flash, g, redirect, render_template, request, url_for
)
import os
from utils import get_random_string
from werkzeug.utils import secure_filename

bp = Blueprint('exploits', __name__, url_prefix='/exploits')


@bp.route('/', methods=('GET', 'POST'))
def index():
    return render_template('exploits.html', EXPLOITS_DATA=get_exploits())


@bp.route('/add-exploit', methods=('GET', 'POST'))
def add_exploit():
    if g.user is None:
        return redirect(url_for('auth.login'))

    if request.method == 'GET':
        return render_template('add-exploit.html', CHALLENGES_DATA=get_challenges(), EXPLOITS_DATA=get_exploits())

    if request.method == 'POST':
        user_id = g.user[0]
        challenge_id = request.form['challenge_id']
        exploit_version = request.form['exploit_version']
        exploit_files = request.files.getlist("exploit_files[]")
        exploit_command = request.form['exploit_command']

        db = get_db()
        error = None
        error_file = False

        if not challenge_id:
            error = 'Challenge id is required.'
        elif not exploit_command:
            error = 'Command is required.'
        elif not exploit_version:
            error = 'Version is required.'
        elif not exploit_files or len(exploit_files) is 0:
            error = 'Files are required.'
            error_file = True
        elif not user_id:
            error = 'User id is required.'

        exploits_paths = []

        if error_file is False:
            base_path = app.config['UPLOADS_FOLDER'] + get_random_string(15) + '/'

            os.mkdir(base_path, 0777)

            # Sandbox installation
            #
            # uid = pwd.getpwnam('InsHackSandbox').pw_uid
            # gid = grp.getgrnam('InsHackSandbox').gr_gid
            #
            # os.chown( base_path, uid, gid)
            # os.chmod( base_path, 0777 )

            for exploit_file in exploit_files:
                exploit_path = base_path + secure_filename(exploit_file.filename)
                exploit_file.save(exploit_path)
                exploits_paths.append(exploit_path)

                # Sandbox installation
                #
                # os.chown( exploit_path, uid, gid)
                # os.chmod( exploit_path, 0777 )
                #
                # print exploit_path

        if error is None:
            db.execute(
                'INSERT INTO exploits (version, command, path, user_id, challenge_id) VALUES (?, ?, ?, ?, ?)',
                (exploit_version, exploit_command, '-_-*+*-_-'.join(exploits_paths), user_id, challenge_id)
            )
            db.commit()
            msg = "Exploit uploaded. ({})".format('\n    '.join(exploits_paths))
            return render_template('add-exploit.html', message=msg, CHALLENGES_DATA=get_challenges(),
                                   EXPLOITS_DATA=get_exploits())

        flash(error)

        return redirect(url_for('exploits.add_exploit', CHALLENGES_DATA=get_challenges(), EXPLOITS_DATA=get_exploits()))


@bp.route('/delete/<id>', methods=['GET'])
def delete_exploit(exploit_id):
    if not is_logged():
        return redirect(url_for('auth.login'))

    db = get_db()
    db.execute(
        'DELETE FROM exploits WHERE id = ?',
        (exploit_id,)
    )
    db.commit()

    return redirect(url_for('exploits.index'))


@bp.route('/toggle-exploit', methods=('GET', 'POST'))
def toggle_exploit():
    if g.user is None:
        return redirect(url_for('auth.login'))

    if request.method == 'GET':
        return redirect(url_for('exploits.index'))

    if request.method == 'POST':
        exploit_id = request.form['exploit_id']

        if exploit_id:
            db = get_db()
            db.execute(
                'UPDATE exploits SET enabled = not enabled WHERE id = ?', (exploit_id,)
            )
            db.commit()

        return redirect(url_for('exploits.index'))


def get_exploits():
    if not is_logged():
        return redirect(url_for('auth.login'))

    final_view = []

    challenges = get_db().execute(
        'SELECT name, port FROM challenges'
    ).fetchall()

    for challenge in challenges:
        challenge_name = challenge[0]
        challenge_port = challenge[1]

        challenge_data = {
            'challenge_name': challenge_name,
            'challenge_port': challenge_port,
            'exploits': []
        }
        final_view.append(challenge_data)

    challenge_exploits = get_db().execute(
        'SELECT C.name, C.port, E.id, E.version, E.path, E.timestamp, E.enabled, U.username ' +
        'FROM challenges AS C, exploits AS E, users AS U ' +
        'WHERE C.id = E.challenge_id AND E.user_id = U.id ' +
        'ORDER BY E.timestamp DESC'
    ).fetchall()

    for challenge_exploit in challenge_exploits:
        challenge_name = challenge_exploit[0]
        challenge_port = challenge_exploit[1]
        exploit_id = challenge_exploit[2]
        version = challenge_exploit[3]
        path = challenge_exploit[4]
        timestamp = challenge_exploit[5]
        enabled = challenge_exploit[6]
        owner_username = challenge_exploit[7]

        exploit_data = {
            'id': exploit_id,
            'version': version,
            'path': path,
            'timestamp': datetime.strptime(timestamp, '%Y-%m-%d %H:%M:%S'),
            'enabled': enabled,
            'owner': owner_username
        }

        exploit_inserted = False

        for item in final_view:
            if item['challenge_name'] == challenge_name and item['challenge_port'] == challenge_port:
                item['exploits'].append(exploit_data)
                exploit_inserted = True

        if not exploit_inserted:
            challenge_data = {
                'challenge_name': challenge_name,
                'challenge_port': challenge_port,
                'exploits': [exploit_data]
            }

            final_view.append(challenge_data)

    return final_view
